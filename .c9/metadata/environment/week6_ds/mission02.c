{"filter":false,"title":"mission02.c","tooltip":"/week6_ds/mission02.c","undoManager":{"mark":6,"position":6,"stack":[[{"start":{"row":28,"column":21},"end":{"row":28,"column":22},"action":"insert","lines":[";"],"id":359}],[{"start":{"row":25,"column":19},"end":{"row":25,"column":20},"action":"insert","lines":["*"],"id":360}],[{"start":{"row":29,"column":4},"end":{"row":29,"column":5},"action":"insert","lines":["*"],"id":361}],[{"start":{"row":28,"column":17},"end":{"row":28,"column":18},"action":"insert","lines":["*"],"id":362}],[{"start":{"row":22,"column":23},"end":{"row":22,"column":24},"action":"remove","lines":[")"],"id":363},{"start":{"row":22,"column":22},"end":{"row":22,"column":23},"action":"remove","lines":["t"]},{"start":{"row":22,"column":21},"end":{"row":22,"column":22},"action":"remove","lines":["x"]},{"start":{"row":22,"column":20},"end":{"row":22,"column":21},"action":"remove","lines":["e"]},{"start":{"row":22,"column":19},"end":{"row":22,"column":20},"action":"remove","lines":["n"]},{"start":{"row":22,"column":18},"end":{"row":22,"column":19},"action":"remove","lines":[">"]},{"start":{"row":22,"column":17},"end":{"row":22,"column":18},"action":"remove","lines":["-"]}],[{"start":{"row":22,"column":12},"end":{"row":22,"column":13},"action":"remove","lines":["("],"id":364}],[{"start":{"row":0,"column":0},"end":{"row":78,"column":0},"action":"remove","lines":["// 연결 리스트로 Stack 만들기","","#include <stdio.h>","#include <stdlib.h>","","typedef struct stackNode {","    int data;","    struct stackNode* next;","} StackNode;","","StackNode* createStackNode(int data) {","    StackNode* node = (StackNode*)malloc(sizeof(StackNode));","    if(!node){","        printf(\"failed to create node\\n\");","        exit(1);","    }","    node->data = data;","    node->next = NULL;","    return node;","}","","int isEmpty(StackNode* root) {","    return !root;","}","","void push(StackNode** root, int data) {","    StackNode* node = createStackNode(data);","","    node->next = *root;","    *root = node;","","    printf(\"%d pushed to stack\\n\", data);","}","","int pop(StackNode** root) {","    if (isEmpty(*root))","        return -9999;","    int popped = (*root)->data;","","    StackNode *tmp = *root;","    *root = (*root)->next;","    free(tmp);","","    return popped;","}","","int peek(StackNode** root) {","    if (isEmpty(*root))","        return -9999;","    return (*root)->data;","}","","int main() {","    StackNode* root = (StackNode*)malloc(sizeof(StackNode));","","    push(&root, 10);","    push(&root, 20);","    push(&root, 30);","    push(&root, 40);","","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","","    push(&root, 50);","    printf(\"%d peeked from stack\\n\", peek(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    return 0;","","    while(root->next == NULL){","        StackNode* tmp = root;","        root = root->next;","        free(tmp);","    }","}",""],"id":365},{"start":{"row":0,"column":0},"end":{"row":77,"column":1},"action":"insert","lines":["// 연결 리스트로 Stack 만들기","","#include <stdio.h>","#include <stdlib.h>","","typedef struct stackNode {","    int data;","    struct stackNode* next;","} StackNode;","","StackNode* createStackNode(int data) {","    StackNode* node = (StackNode*)malloc(sizeof(StackNode));","    if(!node){","        printf(\"failed to create node\\n\");","        exit(1);","    }","    node->data = data;","    node->next = NULL;","    return node;","}","","int isEmpty(StackNode* root) {","    return !root;","}","","void push(StackNode** root, int data) {","    StackNode* node = createStackNode(data);","","    node->next = (*root);","    *root = node;","","    printf(\"%d pushed to stack\\n\", data);","}","","int pop(StackNode** root) {","    if (isEmpty(*root))","        return -9999;","    int popped = (*root)->data;","","    StackNode *tmp = *root;","    *root = (*root)->next;","    free(tmp);","","    return popped;","}","","int peek(StackNode** root) {","    if (isEmpty(*root))","        return -9999;","    return (*root)->data;","}","","int main() {","    StackNode* root = NULL;","","    push(&root, 10);","    push(&root, 20);","    push(&root, 30);","    push(&root, 40);","","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","","    push(&root, 50);","    printf(\"%d peeked from stack\\n\", peek(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    printf(\"%d pop from stack\\n\", pop(&root));","    return 0;","","    while(root->next == NULL){","        StackNode* tmp = root;","        root = root->next;","        free(tmp);","    }","}"]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":77,"column":1},"end":{"row":77,"column":1},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":8,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1598187758453,"hash":"3c869f338be19350664414d8566d46450940c235"}